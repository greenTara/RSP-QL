<!DOCTYPE html>
<html>
  <head>
    <title>RDF Stream Abstract Syntax and Semantics</title>
    <meta charset="utf-8">
      <script src="http://www.w3.org/Tools/respec/respec-w3c-common"
            async class="remove"></script>
      <script class="remove">
      var respecConfig = {
          specStatus: "CG-DRAFT",
          shortName:  "rdf-stream-semantics",
          editors: [
            {
              name:       "Editor 1",
              company:    "Company 1",
              companyURL: "http://example1.com/",
              mailto: "ed1@example1.com"
            },
            {
              name:       "Editor 2",
              company:    "Company 2",
              companyURL: "http://example2.com/",
              mailto: "ed2@example1.com"
            }
          ],
          authors: [
            {
              name:       "Tara Athan",
              company:    "Athan Services",
              companyURL: "http://athant.com",
              mailto: "taraathan@gmail.com"
            },
            {
              name:       "Author 2",
              company:    "Company 2",
              companyURL: "http://example2.com/",
              mailto: "auth2@example1.com"
            }
          ],
          wg:           "RDF Stream Processing Community Group",
          wgURI:        "https://www.w3.org/community/rsp/",
          wgPublicList: "public-rsp",

          localBiblio:  {
            "LINEARCOMPOSITION": {
              title: "Multi-device Linear Composition on the Web: Enabling Multi-device Linear Media with HTMLTimingObject and Shared Motion",
              href: "https://sites.google.com/site/mediasynchronization/Paper4_Arntzen_webComposition_CR.pdf?attredirects=0&d=1",
              authors: [
                "Ingar M. Arntzen",
                "Njål T. Borch",
                "François Daoust",
                "Dominique Hazaël-Massieux"
              ]
            },
            "BLOGIC": {
              title:    "Blogic",
              href:     "http://www.slideshare.net/PatHayes/blogic-iswc-2009-invited-talk",
              authors:  [
                "Pat Hayes"
              ]
            },
            "DVB-CSS": {
              title: "ETSI TS 103 256-2 V1.1.1 Digital Video Broadcasting (DVB); Companion Screens and Streams; Part 2: Content Identification and Media Synchronization",
              href: "http://www.etsi.org/modules/mod_StandardSearch/pdf.png"
            },
            "SHAREDMOTION": {
              title: "Shared Motion",
              href: "http://motioncorporation.com"
            },
            "MEDIASYNC":{
              title: "MediaSync",
              href: "https://github.com/webtiming/mediasync"
            },
            "SEQUENCER" : {
              title: "Open-source sequencer library",
              href: "https://github.com/webtiming/sequencer"
            }
          },
          otherLinks: [
            {
              key: "Version history",
              data: [
                {
                  value: "GitHub streamreasoning/RSP-QL/commits",
                  href: "https://github.com/streamreasoning/RSP-QL/commits/"
                }
              ]
            },
            {
              key: "Participate",
              data: [
                {
                  value: "GitHub streamreasoning/RSP-QL",
                  href: "https://github.com/streamreasoning/RSP-QL"
                },
                {
                  value: "File an issue",
                  href: "https://github.com/streamreasoning/RSP-QL/issues/new"
                },
                {
                  value: "Open issues",
                  href: "https://github.com/streamreasoning/RSP-QL/issues/"
                },
                {
                  value: "Mailing-list (public-rsp@w3.org)",
                  href: "https://lists.w3.org/Archives/Public/public-rsp/"
                }
              ]
            }
          ],

          issueBase: "https://github.com/streamreasoning/RSP-QL/issues/",
          githubAPI: "https://api.github.com/repos/streamreasoning/RSP-QL"
      };
    </script>
      <style type="text/css">
      table { border-collapse: collapse; border-style: hidden hidden none hidden; }
      table thead, table tbody { border-bottom: solid; }
      table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
    </style>
  </head>
  <body>
    <!-- ABSTRACT -->
    
    <section id="abstract">
    </section>
    
    <!-- STATUS OF DOCUMENT -->
    
    <section id="sotd">
      <p>
        The specification is intended for discussion within the RDF Stream Processing Community Group. Its content does not yet represent the consensus of the Community Group.
      </p>
      <p class="warning">
        This specification is incomplete.
      </p>
    </section>
    
    <!-- INTRODUCTION -->
    
    <section class="informative">
      <h2>Introduction</h2>
    </section>
    
    <section>
      
    <h2>RSP Data model</h2>
      
    <h3>Temporal entities</h3>
    
    <p>Let T denote the set of temporal entities. This specification is neutral regarding the formal specification of temporal entities.</p>
    
    <h4>Instants and Intervals</h4> 

    <p>Following the concepts of the Time Ontology (<a href="http://www.w3.org/TR/owl-time/">http://www.w3.org/TR/owl-time/</a>), a temporal entity can be a time instant or a time interval.</p>
    <section id="def-timestamped-graph">
    <h3>Timestamped graph</h3>
    
      <p>A <em>timestamped graph</em> is defined as an RDF Dataset under the RDF Dataset semantics that <a href="http://www.w3.org/TR/2014/NOTE-rdf11-datasets-20140225/#each-named-graph-defines-its-own-context">"each named graph defines its own context"</a> (see <a href="#semantics"></a>) and where a particular triple in the default graph has been designated as the timestamp triple, with the following constraints:</p>
    
    <ol>
      <li>There is exactly one named graph pair <code>&lt;n, G></code> in the RDF Dataset (where <code>G</code> is an <a href="http://www.w3.org/TR/rdf11-concepts/#section-rdf-graph">RDF graph</a>, and <code>n</code> is an IRI or blank node).</li>
      <li>The timestamp triple has the form <code>&lt;n, p, t></code>, where <code>n</code> is defined in the previous item, and <code>p</code> is a timestamp predicate that captures the relationship between the temporal entity <code>t</code>, called the timestamp, and the graph <code>G</code>.</li>
    </ol>
      <p class="note">There may be multiple triples in the default graph, including multiple triples using timestamp predicates, 
        but exactly one triple must be designated as the timestamp triple.</p>
      <p class="ednote">Due to the assertion of the timestamp triple, the context referred to in "each named graph defines its own context" has a temporal aspect to it.
        Other aspects of this context may be asserted by additional triples in the default graph of the timestamped graph.
        Such triples are not required to have timestamp predicates, and thus may be about non-temporal aspects of the context,
        e.g. the authority or the sensor device.
        That is, we require the context to have a temporal aspect to it, but the context is not limited to temporal aspects.
        Thus, it would be misleading to call it a "temporal context".
      </p>
      <p class="ednote">The part of the definition above that points to RDF Dataset semantics really belongs in the semantics section, not
      in this definition, which should be purely syntax.
      We need additional informative text that gives the motivation for these definitions.
      </p>
      
    <p class="ednote">This definition does not permit the timestamp to be omitted, which is one of the data structures
      that is considered to be in-scope by the requirements document.
    </p>
      <p>
      A sequence of RDF graphs (or named graphs, or RDF datasets) MAY be physically received by an RSP engine, 
      which MAY then create an RDF stream from it by adding timestamps, e.g. indicating the time of arrival. 
      The original sequence is not itself an RDF stream.
    </p>
      <p class="note">
        This definition allows the timestamp to be an IRI or blanknode. 
        Additional information about the timestamp may be provided in the default graph (e.g. through properties in the OWL Time Ontology), 
        but this is not required by the definition of timestamped graph.
    </p>
      
      <p>A <em>literal-timestamped graph</em> is a timestamped graph whose timestamp <code>t</code> is an rdf:Literal.</p>
      
      <p class="ednote">Merge and union of RDF streams with non-literal-timestamped graphs may not be defined. See <a href="#merge-union"></a>.</p>
          
      <p class="ednote">The timestamp predicate <code>p</code> may be drawn from a community agreed 
        vocabulary (<a href="https://github.com/streamreasoning/RSP-QL/issues/10">Issue 10</a>).
        The timestamp predicate may also be user-defined.
      </p>

      <p>
        The format in the examples of this document follows <a href="http://www.w3.org/TR/trig/">TriG</a>, although does not imply any specific serialization or formatting; 
        it simply shows the data structured according to the RDF stream model.  
        When the default graph of a timestamped graph contains only one triple, this must be the timestamp triple, so there is no need of an additional format to designate it. 
        In examples of timestamped graphs having more than one triple in the default graph, the first triple of the default graph to occur in the serialization
        is assumed to be the timestamp triple.
        Prefixes (e.g. <code>prov:</code>, <code>dul:</code>) are used, without explicitly defining their expansion, for readability.</p>
      <p class="ednote">A non-normative subsection should be created to hold all the information about the formatting of examples, and there
        the expansion of all prefixes that are used in examples can be defined.</p>
      
    <aside class="example" id="literal-TSG" title="Literal-Timestamped Graph">
    
      <p>The following timestamped graph contains a named graph pair <code>&lt;:g1, G></code> where the graph <code>G</code> 
        contains two triples that state that entities <code>:darko</code> and <code>:axel</code> are in the <code>:RedRoom</code>. 
        The timestamp predicate <code>p</code> used in this example is the [[PROV-O]] property 
        <a href="https://www.w3.org/TR/prov-o/#generatedAtTime"><code>prov:generatedAtTime</code></a>.
        The purpose of this timestamp triple is to add a temporal aspect to the context of the named graph pair,
        to the effect that the temporal entity <code>"2001-10-26T21:32:52Z"^^xsd:dateTime</code> 
        is the time at which the entity <code>:g1</code> "was completely created and is available for use".
        The details of the semantics of the named graph pair in a timestamped graph are provided in <a href="#semantics"></a>
      </p>
    
      <pre><code  class="highlight">:g1 {:axel :isIn :RedRoom. :darko :isIn :RedRoom} {:g1,prov:generatedAtTime,"2001-10-26T21:32:52Z"^^xsd:dateTime}
</code></pre>
    </aside>
      
      <p class="ednote">According to the semantics defined in <a href="#semantics"></a>, the assertion of the named graph pair
        means that the graph denoted by <code>:g</code> entails the two triples <code>:axel :isIn :RedRoom</code>
      and <code>:darko :isIn :RedRoom</code>, under whatever entailment regime is being considered. 
        It does not assert those triples directly, nor does it assert that these triples
        are actually in that graph. Further, it does not rule out additional entailments of <code>:g</code>.
        These details are best explained in the semantics section itself, although it would probably be helpful
        to have some informative explanation near the beginning to avoid confusion.
    </p>
      
      <aside class="example" id="non-literal-TSG" title="Non-Literal-Timestamped Graph">
        <p>The following timestamped graph contains a named graph pair <code>&lt;:g2, G></code> where the graph <code>G</code> 
          contains one triple that states that entity <code>:axel</code> leaves the <code>:BlueRoom</code>. 
          The timestamp predicate used in this example is the DOLCE+DnS Ultralite property 
          <a href="http://www.loa-cnr.it/ontologies/DUL.owl#isObservableAt"><code>dul:isObservableAt</code></a>.
          The purpose of this timestamp triple is to add a temporal aspect to the context of the named graph pair,
          to the effect that there is 
          some time <code>_:t2</code> at which an observation could have been (or be) made where the results of that observation
          are described by the entity <code>:g2</code>.
          There is an additional triple in the default graph that compares the observable time
          to some other time <code>_:t1</code> using the Allen interval relation 
          <a href="https://www.w3.org/2006/time#after"><code>owl:after</code></a>
          from [[OWL-TIME]].
        </p>
        <pre><code class="highlight">
          :g2 dul:isObservableAt _:t2.
          :g2 {:axel :leave :BlueRoom. }
          _:t2 time:after _:t1
        </code></pre>
      </aside>
    </section>
    
    <h3>RDF Stream</h3>
    
      <p>An <em>RDF stream</em> <code>S</code> consists of a sequence of timestamped graphs whose elements sharing the same predicate are ordered by the partial order associated with this predicate on the timestamps. I.e., if a stream <code>S</code> contains elements <code>S(i)</code> and <code>S(j)</code> with <code>i &lt; j</code> whose timestamp triples contain the same timestamp predicate <code>p</code>, then it should not be the case that the timestamp of <code>S(i)</code> is greater than the timestamp of <code>S(j)</code>. </p>
    
    <p><strong>Order:</strong> The partial order MUST respect the natural order of time. In particular, if every time instant within the closure of temporal entity <code>X</code> is earlier than every time instant within the closure of temporal entity <code>Y</code>, then <code>X &lt;= Y</code> (where closure of a time instant <code>t</code> is defined as the degenerate interval <code>[t, t]</code>, and closure of an interval is defined in the usual way) </p>
    
    <p>Furthermore, the usual mathematical requirements of a partial order apply:</p>
    
    <ul>
      <li>a) Reflexivity <code>X &lt;= X</code></li>
      <li>b) Antisymmetry <code>X &lt;= Y</code> and <code>Y &lt;= X</code> implies <code>X = Y</code></li>
      <li>c) Transitivity <code>X &lt;= Y</code> and <code>Y &lt;= Z</code> implies <code>X &lt;= Z</code>. </li>
    </ul>
      
      <p class="ednote">Time-boundedness properties on RDF streams behave better if it is required that the set of temporal entities for each timestamp predicate is pairwise bounded. I.e., for each pair of temporal entities in the set, there is a temporal entity in the set that is an upper bound of both, as well as a temporal entity in the set that is a lower bound of both.</p>
      
    <p class="ednote">The comparability between any pair of elements of an RDF stream must be completely determined
      from the default graphs of the elements.
    Otherwise the ordering could be revealed by a subsequent element, inducing retroactively an
    ordering requirement on previous stream elements.</p>
    
    <p>On the following we may refer to RDF stream simply as stream.</p>
    
    <aside class="example" id="literal-rdf-stream" title="RDF Stream">
    
    <p>An RDF stream produces data that indicates where a person is at a given time. The timestamp predicate <code>p</code> used in this example is the PROV `<code>prov:generatedAtTime</code>. In this example the named graphs (<code>:g1</code>,<code>:g2</code>, etc.) contain the streaming data contents (for brevity the contents are represented by the dots <code>...</code>). </p>
    
    <pre class="highlight"><code>:g1 {...}{:g1,prov:generatedAtTime,t1}
:g2 {...} {:g2, prov:generatedAtTime, t2}
:g3 {...} {:g3, prov:generatedAtTime, t3}
:g4 {...} {:g4, prov:generatedAtTime, t4}
...
</code></pre>
    
    <p>We can expand the content of each named graph, which is a set of triples:</p>
    
    <pre  class="highlight"><code>
:g1 {:axel :isIn :RedRoom. :darko :isIn :RedRoom} 
  {:g1, prov:generatedAtTime, "2015-06-18T12:00:00Z"^^xsd:dateTime}
:g2 {:axel :isIn :BlueRoom. }                     
  {:g2, prov:generatedAtTime, "2015-06-18T12:00:35"^^xsd:dateTime}
:g3 {:minh :isIn :RedRoom. }                      
  {:g3, prov:generatedAtTime, "2015-06-18T12:02:07"^^xsd:dateTime}
...
</code></pre>
      </p>
    </aside>
    
    <p class="note">There can be multiple graphs with the same timestamp in the stream.</p>
    
      <p class="ednote">It has been pointed out that this statement might be problematic, as graphs could no longer be used for punctuation purposes. Comparatively, we have not found a constraint on this in similar models e.g. CQL: <em>there could be zero, one, or multiple elements with the same timestamp in a stream</em>.</p>
    
    <section>
    <h3>Isomorphism</h3>
        <p>Two RDF timestamped graphs TSG1 and TSG2 are <em>isomorphic</em> if and only if there is a bijection M between the nodes, triples, graphs and named graphs in TSG1 and those in TSG2 such that:
          <ol>
            <li>M maps blank nodes to blank nodes;</li>
            <li>M is the identity map on literals and IRIs;</li>
            <li>For every triple &lt;s p o>, M(&lt;s, p, o>)= &lt;M(s), M(p), M(o)>;</li>
            <li>For every graph G={t1, ..., tn}, M(G)={M(t1), ..., M(tn)};</li>
            <li>For every named graph NG=&lt;n, G>, M(NG)=&lt;M(n), M(G)>;</li>
            <li> M(NG1)=NG2,  M(DG1)=DG2, and M(TST1)=TST2,
              where NG1 is the named graph of TSG1, DG1 is the default graph of TSG1, TST1 is the timestamp triple of TSG1, and similarly for TSG2.</li>
          </ol>
        </p>
      <p class="ednote">If timestamped graphs are only allowed to have singleton default graphs, then some of the last bullet is redundant.
      </p>
      <p class="note">
        The definition of timestamped graphs allows blank nodes to be used as graph names, as well as within graphs.
      </p>
      <pre class="example highlight" title="Isomorphic Timestamped Graphs with Blank-Node Graph Names">
<code>:_1 {...} {:_1, prov:generatedAtTime, t1}
</code>

<code>:_2 {...} {:_2, prov:generatedAtTime, t1}
</code>
      
      </pre>
      
      <p>Two RDF streams are <em>S-isomorphic</em> if and only if they have the same set of elements.</p>
    <pre class="example highlight" title="S-Isomorphic Streams with Unique Well-Ordered Timestamp Predicate">
<code>
:g1 {...} {:g1, prov:generatedAtTime, t1}
:g2 {...} {:g2, prov:generatedAtTime, t2}
:g3 {...} {:g3, prov:generatedAtTime, t2}
:g4 {...} {:g4, prov:generatedAtTime, t3}
</code>

<code>
:g1 {...} {:g1, prov:generatedAtTime, t1}
:g3 {...} {:g3, prov:generatedAtTime, t2}
:g2 {...} {:g2, prov:generatedAtTime, t2}
:g4 {...} {:g4, prov:generatedAtTime, t3}
</code>
    </pre>  

      <p>Two RDF streams S1 and S2 are <em>B-isomorphic</em> if and only if there is a bijection M between the nodes, triples, graphs, named graphs, and timestamped graphs in S1 and those in S2 such that:
        <ol>
          <li>M maps blank nodes to blank nodes;</li>
          <li>M is the identity map on literals and IRIs;</li>
          <li>For every triple &lt;s p o>, M(&lt;s, p, o>)= &lt;M(s), M(p), M(o)>;</li>
          <li>For every graph G={t1, ..., tn}, M(G)={M(t1), ..., M(tn)};</li>
          <li>For every named graph NG=&lt;n, G>, M(NG)=&lt;M(n), M(G)>;</li>
          <li>For every timestamped graph TSG where NG is the named graph and DG is the default graph containing the timestamp triple TST, M(TSG) is a timestamped graph TSG2, with named graph M(NG), default graph M(DG) and timestamp triple M(TST).;</li>
          <li>For every i &ge; 1, M(S1(i))=S2(i), where S1(i) is the i-th element of S1 and S2(i) is the i-the element of S2.</li>
        </ol>
      </p>
      
      <p class="note">An RDF stream is viewed as being on a single "RDF surface"(see [[BLOGIC]]), so that blank nodes may be shared between any graphs in the stream.
      For this reason, B-isomorphism is defined in terms of a single mapping M for the entire RDF stream rather than, say, separate mappings for each timestamped graph.</p>
      
      <p>Two RDF streams are <em>isomorphic</em> if there exists an RDF stream that is both B-isomorphic to one stream and S-isomorphic to the other stream.</p>
    </section>
    
      <p class="note">
          RDF streams that are S-isomorphic are isomorphic.
      </p>
      <p class="note">
          RDF streams that are B-isomorphic are isomorphic.
      </p>

      <p>Isomorphic RDF streams MUST have the same semantics. The semantics of RDF streams is affected by the result of applying window functions (<a href='#window-functions'></a>) as well as by entailment.
      Therefore, isomorphic RDF streams SHALL be indistinguishable, up to isomorphism, with respect to entailment (in any entailment regime), as well as with respect to the application of window functions.
      </p>
    </section>
    <section>
      <h3>Substream</h3>
    
    <p>A <em>substream</em> (also known as window) <code>S'</code> of a stream <code>S</code> is a subsequence of <code>S</code>.</p>
    
    <h4>Time-bounded Substream</h4>
    
    <p>A <em>time-bounded substream</em> is defined by two time instances providing a lower bound <code>t_l</code> and an upper bound <code>t_u</code> where <code>t_l &lt;= t_u</code>. A timestamped graph <code>(g_i,p_i,t_i)</code> is in the time-bounded substream if and only if <code>t_l &lt;= t_i &lt;= t_u</code>.</p>
    
    <h4>Count-bounded Substream</h4>
    
    <p>A <em>count-bounded substream</em> is defined by a time instance <code>t</code> and an integer value <code>n</code> that represents the number of timestamped graphs to include in the count-bounded substream. The count-bounded substream consists of the <code>n</code> timestamped graphs at or before time instance <code>t</code>. That is, a timestamped graph <code>(g_i,p_i,t_i)</code> is in the count-bounded substream if and only if there are less than or equal to <code>n</code> timestamped graphs between it and the time instance <code>t</code>.</p>
    
    <p  class="note">A bounded substream maintains the timestamped graph contexts of the original stream.</p>
    
    <blockquote>
      <p>See <a href="https://github.com/streamreasoning/RSP-QL/issues/11">Issue 11</a>.</p>
    </blockquote>
    </section>
    <section>
    
    <h2>Stream Merger and Union Operations</h2>
    </section>
    <section id="window-functions">
    
    <h2>Window Functions</h2>
    
    <blockquote>
      <p  class="note">Window operator is reserved for later use to return time-varying graphs. Window functions work on a time instant. </p>
      
      <p class="note">In the following, we take the case where temporal entities in the stream are time instants.</p>
      
      <p>Open Issue: <a href="https://github.com/streamreasoning/RSP-QL/issues/18">Issue 18</a></p>
    </blockquote>
    
    <p>A <em>window function</em> <code>w<sub>ι</sub></code> of type <code>ι</code> takes as input a stream <code>S</code>, a predicate <code>p</code>, a time instant <code>t</code>, called the reference time point, and a vector of window parameters <code>x</code> for type <code>ι</code> and returns a substream <code>S'</code> of <code>S</code> that contains only timestamped graphs associated with <code>p</code> and timestamps valid at <code>t</code> according <code>ι</code> and <code>x</code>.</p>
    
    <p>The most common types of windows in practice are time-based and count-based. We associate them with the window functions <code>w<sub>τ</sub></code>, <code>w<sub>#</sub></code>, respectively. They take a fixed size ranging back in time from a reference time point <code>t</code>. These functions work as follows.</p>
    
    <h3>Time-based window functions</h3>
    
    <p><code>x = (l,d)</code>, where <code>l ∈ N ∪ {∞}</code> and <code>d ∈ N</code>. The function <code>w<sub>τ</sub>(S,p,t,x)</code> returns the substream of S that contains all timestamped graphs associated with predicate <code>p</code> of the last <code>l</code> time units relative to a pivot time point <code>t'</code> derived from <code>t</code> and the step size <code>d</code> (Todo: MD: a figure to illustrate). We use <code>l = ∞</code> to take all previous timestamped graphs.</p>
    
    <p>Formally:</p>
    
    <p><code>w<sub>τ</sub>(S,p,t,(l,d)) = {((n,g),p,t<sub>1</sub>)∈ S ∣ t'-l &lt; t<sub>1</sub> ≤ t'}</code>, </p>
    
    <p>where <code>t'= ⌊t/d⌋ \cdot d</code></p>
    
    <h3>Count-based window functions</h3>
    
    <p><code>x = (l)</code>, where <code>l ∈ N</code>. The function <code>w<sub>#</sub>(S,p,t,x)</code> selects a substream <code>S<sub>1</sub></code> of <code>S</code> based on the time instant <code>t'</code> satisfying that:</p>
    
    <ul>
      <li>for every <code>t' &lt; t'' ≤ t</code>, there are fewer than <code>l</code> timestamped graphs associated with predicate <code>p</code> in <code>S</code> from <code>t''</code> to <code>t</code>,</li>
      <li>there are at least <code>l</code> timestamped graphs associated with predicate <code>p</code> in <code>S</code> from <code>t'</code> to <code>t</code>.</li>
    </ul>
    
    <p>Elements from <code>S<sub>1</sub></code> are those <code>((n<sub>i</sub>,g<sub>i</sub>),p,t<sub>i</sub>)</code> from <code>S</code> having <code>t<sub>i</sub> ≥ t'</code>. In case there are more than <code>l</code> timestamped graphs associated with predicate <code>p</code> in <code>S</code> from <code>t'</code> to <code>t</code>, only timestamped graphs at <code>t'</code> are removed at random.</p>
    
    <p>Formally:</p>
    
    <p><code>w<sub>#</sub>(S,p,t,(l)) = {((n,g),p,t'') ∈ S ∣ t' &lt; t'' ≤ t} ∪ X(S|<sub>p</sub>[t',t'], l - #S|<sub>p</sub>[t'+1,t])</code>,</p>
    
    <p>where</p>
    
    <ul>
      <li><code>S|<sub>p</sub>[t<sub>1</sub>,t<sub>2</sub>] = {((n,g),p,t'') ∈ S ∣ t<sub>1</sub> ≤ t'' ≤ t<sub>2</sub>}</code>,</li>
      <li><code>#S|<sub>p</sub>[t<sub>1</sub>,t<sub>2</sub>]</code> is the number of elements of this set,</li>
      <li><code>t'</code> satisfies that <code>#S|<sub>p</sub>[t',t] ≥ l</code> and <code>#S|<sub>p</sub>[t'+1,t] &lt; l</code> </li>
    </ul>
    </section>
    
    <!--<h2>References:</h2>
    
    <ul>
      <li>EP-SPARQL: a unified language for event processing and stream reasoning.
        Anicic, D., Fodor, P., Rudolph, S., &amp; Stojanovic, N. In WWW (p. 635-644). ACM. 2011.</li>
      <li>C-SPARQL: a Continuous Query Language for RDF Data Streams. 
        Barbieri, D. F., Braga, D., Ceri, S., Della Valle, E., &amp; Grossniklaus, M. Int. J. Semantic Computing, 4(1), 3-25. 2010.</li>
      <li>Enabling query technologies for the semantic sensor web. 
        Calbimonte, J.-P., Jeung, H., Corcho, Ó., &amp; Aberer, K. Int. J. Semantic Web Inf. Syst., 8(1), 43-63. 2012.</li>
      <li>RSP-QL Semantics: a Unifying Query Model to Explain Heterogeneity of RDF Stream Processing Systems. 
        D. Dell’Aglio, E. Della Valle, J.-P. Calbimonte, O. Corcho. Int. J. Semantic Web Inf. Syst, 10(4). (in press). 2015.</li>
      <li>A Native and Adaptive Approach for Unified Processing of Linked Streams and Linked Data.
        Phuoc, D. L., Dao-Tran, M., Parreira, J. X., &amp; Hauswirth, M.In ISWC (Vol. 7031, p. 370-388). Springer. 2011.</li>
      <li>LARS: A Logic-based Framework for Analyzing Reasoning over Streams.
        Beck, H., Dao-Tran, M., Eiter, T., Fink, M. In AAAI. 2015.</li>
      <li>RDF 1.1: On Semantics of RDF Datasets. Zimmerman, Antoine, ed.. 2014.  <a href="http://www.w3.org/TR/2014/NOTE-rdf11-datasets-20140225">http://www.w3.org/TR/2014/NOTE-rdf11-datasets-20140225</a>.</li>
    </ul>-->
    
    <blockquote>
      <p class="note">this example could be integrated to the main text body</p>
      
      <h3>Beyond time instants: intervals &amp; more</h3>
      
      <p>Usign the previously described model, intervals can be specified for a graph in the following way: Given p1 and p2 representing start and end time predicates, then <code>(g,p1,t1)</code> and <code>(g,p2,t2)</code> denote that g is defined in an interval [t1,t2]. As an example:</p>
      
      <pre  class="example highlight" title="RDF Stream with Two Timestamp Predicates for One Named Graph"><code>:g_1, :startsAt, "2015-06-18T12:00:00"^^xsd:dateTime
:g_1, :endsAt, "2015-06-18T13:00:00"^^xsd:dateTime
</code></pre>
      
      <p>Or even:</p>
      
      <pre  class="example highlight" title="RDF Stream with Interval Timestamp"><code>:g_2 :validBetween
    [:startsAt "2015-06-18T12:00:00"^^xsd:dateTime;
    :endsAt "2015-06-18T13:00:00"^^xsd:dateTime]
</code></pre>
    </blockquote>
    
    <section id="profiles">
      <h2>Profiles</h2>
      <p>It is possible to restrict the abstract syntax for a class of RDF streams.
      This is often done in order to facilitate the efficient implementation of certain operations and queries or
      to promote more efficient representation.
      Each such restriction constitutes an <em>RDF stream profile</em>.</p>
      <p>The profiles defined in this document fall into two categories: time-series profiles and linked-list profiles.
         Within each category there is a least-restrictive profile and a number of subprofiles which apply additional restrictions to it.</p>
    
      <section id="timeseries">
      <h3>RDF Time-Series Profiles</h3>
      <p>This section describes three profiles which are defined through restrictions on the default graphs of the stream's timestamped graph elements
      or on the relation between timestamp values:
      <ul><li>RDF time series</li>
      <li>RDF distinct time series</li>
      <li>RDF synchronous (or regular) time series</li></ul></p>
      <section id="time-series-profile">
        <h4>RDF Time-Series Profile</h4>
        <p>The RDF Stream Time-Series profile is designed to support high-volume, low-latency window operations and queries that depend on full knowledge of timestamps.</p>
        <p class="ednote">This motivational paragraph needs some work - the above is a place holder.</p>
        
        <p>An <em>RDF time series</em> is an RDF stream that satisfies the following properties:</p>
        <ol>
          <li>The stream uses exactly one timestamp predicate.</li>
          <li>The range of this timestamp predicate is xsd:dateTimeStamp.</li>
          <li>No two elements in the time series have the same graph name.</li>
        </ol>
        <aside class="example">
          <p><a href="#literal-rdf-stream">Example 4</a> satisfies the first and third requirements of the time-series profile. However, the range of the predicate <code>prov:generatedAtTime</code> is not limited to xsd:dateTimeStamp - non-timezoned values of xsd:dateTime are also permitted.</p>          
        </aside>
        <p class="ednote">If some property (e.g. in the RSP-QL namespace)
          is defined as a subproperty of <code>prov:generatedAtTime</code>,
          then this can be substituted in <a href="#literal-rdf-stream">Example 4</a>, which will then
          serve as an example of a time series.
          Alternatively, the definition could be changed so that the only requirement
          is that the timestamps that occur in the stream belong to xsd:dateTime.
        </p>
        
        <p class="note">The set of RDF time series is closed under RDF stream merge 
          and union on time series that use the same timestamp predicate.</p>
        </section>
          
        <section id="distinct-time-series-profile">
        <h4>RDF Distinct Time-Series Profile</h4>
        <p>An "RDF distinct time series" is an RDF time series such that no 
          two elements in the time series have the same timestamp.</p>
        
        <aside class="example">
          <p> A distinct time series example ...</p>          
        </aside>
        
        <p class="note">An RDF distinct time series has a 
          unique sequential order - it is S-isomorphic only to itself.</p>
        <p class="note">The merge or union of RDF distinct time series
          is always defined but 
          is not necessarily an RDF distinct time series, even if the operation
          is restricted to time series that use the same timestamp predicate, due
          to the possibility of duplication of timestamp. 
          However, the merge or union of RDF distinct time series that use the 
          same timestamp predicate is always an RDF time series.
          </p>
        
        <p class="ednote">The restriction of typical window relations 
          (i.e. time-based and count-based, see pull request #42)
        to distinct time series results in functional relations.
        This enables the definition of window functions based on those window relations.
        Further, the count-based window functions are always computable.
        However, the time-based window functions are not necessarily computable
        unless there is a finite precision to the timestamps, 
        as can be seen from the Zeno's paradox example 
        @@@(this example hasn't been written up yet, but is mentioned in pull request #35).
        </p>
        
        <p class="ednote">There is going to be a lot more to talk about
        for RDF time series relative to queries, but in this document 
        we don't have those definitions.</p>
        </section>
        
        <section id="synchronous-time-series-profile">
        <h4>RDF Synchronous Time-Series Profile</h4>
        A <em>synchronous</em> RDF time series is a further subclass of distinct time series with a particular duration between timestamps.
        This is also called a regular time series.
        <aside class="example">
          <p> A synchronous time series example ...</p>          
        </aside>
        </section>
      </section>

      <section id="linked-list-profiles">
        <h3>RDF Linked-List Profiles</h3>
      </section>
      
      <aside  class="ednote"><p>In order to indicate which profile applies to a stream, the transmission must include that information in addition to the stream content.
       For streams which are delivered the method is to sullpy the profile as a <code>profile</code> parameter to the media type.
       The following profiles are defined
       <ul>
         <li><code>http://www.w3.org/ns/rsp-ql#time-series</code></li>
         <li><code>http://www.w3.org/ns/rsp-ql#distinct-time-series</code></li>
         <li><code>http://www.w3.org/ns/rsp-ql#synchronous-time-series</code></li>
         <li><code>http://www.w3.org/ns/rsp-ql#linked-stream</code></li>
       </ul>
       </p></aside>

    </section>
    
    <!-- CONFORMANCE -->
    
    <section id="conformance">
    </section>
    
  </body>
</html>

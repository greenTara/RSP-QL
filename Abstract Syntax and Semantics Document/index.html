<!DOCTYPE html>
<html>
  <head>
    <title>RDF Stream Abstract Syntax and Semantics</title>
    <meta charset="utf-8">
      <script src="http://www.w3.org/Tools/respec/respec-w3c-common"
            async class="remove"></script>
      <script class="remove">
      var respecConfig = {
          specStatus: "CG-DRAFT",
          edDraftURI: "http://streamreasoning.github.io/RSP-QL/Abstract%20Syntax%20and%20Semantics%20Document/",
          shortName:  "rdf-stream-semantics",
          editors: [
            {
              name:       "Editor 1",
              company:    "Company 1",
              companyURL: "http://example1.com/",
              mailto: "ed1@example1.com"
            },
            {
              name:       "Editor 2",
              company:    "Company 2",
              companyURL: "http://example2.com/",
              mailto: "ed2@example1.com"
            }
          ],
          authors: [
            {
              name:       "Tara Athan",
              company:    "Athan Services",
              companyURL: "http://athant.com",
              mailto: "taraathan@gmail.com"
            },
            {
              name:       "Author 2",
              company:    "Company 2",
              companyURL: "http://example2.com/",
              mailto: "auth2@example1.com"
            }
          ],
          wg:           "RDF Stream Processing Community Group",
          wgURI:        "https://www.w3.org/community/rsp/",
          wgPublicList: "public-rsp",

          localBiblio:  {
            "LINEARCOMPOSITION": {
              title: "Multi-device Linear Composition on the Web: Enabling Multi-device Linear Media with HTMLTimingObject and Shared Motion",
              href: "https://sites.google.com/site/mediasynchronization/Paper4_Arntzen_webComposition_CR.pdf?attredirects=0&d=1",
              authors: [
                "Ingar M. Arntzen",
                "Njål T. Borch",
                "François Daoust",
                "Dominique Hazaël-Massieux"
              ]
            },
            "MSV": {
              title:    "The Media State Vector: A unifying concept for multi-device media navigation",
              href:     "http://dl.acm.org/citation.cfm?doid=2457413.2457427",
              authors:  [
                "Ingar M. Arntzen",
                "Njål T. Borch",
                "Christopher P. Needham"
              ]
            },
            "DVB-CSS": {
              title: "ETSI TS 103 256-2 V1.1.1 Digital Video Broadcasting (DVB); Companion Screens and Streams; Part 2: Content Identification and Media Synchronization",
              href: "http://www.etsi.org/modules/mod_StandardSearch/pdf.png"
            },
            "SHAREDMOTION": {
              title: "Shared Motion",
              href: "http://motioncorporation.com"
            },
            "MEDIASYNC":{
              title: "MediaSync",
              href: "https://github.com/webtiming/mediasync"
            },
            "SEQUENCER" : {
              title: "Open-source sequencer library",
              href: "https://github.com/webtiming/sequencer"
            }
          },
          otherLinks: [
            {
              key: "Version history",
              data: [
                {
                  value: "GitHub streamreasoning/RSP-QL/commits",
                  href: "https://github.com/streamreasoning/RSP-QL/commits/"
                }
              ]
            },
            {
              key: "Participate",
              data: [
                {
                  value: "GitHub streamreasoning/RSP-QL",
                  href: "https://github.com/streamreasoning/RSP-QL"
                },
                {
                  value: "File an issue",
                  href: "https://github.com/streamreasoning/RSP-QL/issues/new"
                },
                {
                  value: "Open issues",
                  href: "https://github.com/streamreasoning/RSP-QL/issues/"
                },
                {
                  value: "Mailing-list (public-rsp@w3.org)",
                  href: "https://lists.w3.org/Archives/Public/public-rsp/"
                }
              ]
            }
          ],

          issueBase: "https://github.com/streamreasoning/RSP-QL/issues/",
          githubAPI: "https://api.github.com/repos/streamreasoning/RSP-QL"
      };
    </script>
      <style type="text/css">
      table { border-collapse: collapse; border-style: hidden hidden none hidden; }
      table thead, table tbody { border-bottom: solid; }
      table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
    </style>
  </head>
  <body>
    <!-- ABSTRACT -->
    
    <section id="abstract">
    </section>
    
    <!-- STATUS OF DOCUMENT -->
    
    <section id="sotd">
      <p>
        The specification is intended for discussion within the RDF Stream Processing Community Group. Its content does not yet represent the consensus of the Community Group.
      </p>
      <p class="warning">
        This specification is incomplete.
      </p>
    </section>
    
    <!-- INTRODUCTION -->
    
    <section class="informative">
      <h2>Introduction</h2>
    </section>
    
    <section>
      
    <h2>RSP Data model</h2>
      
    <h3>Temporal entities</h3>
    
    <p>Let T denote the set of temporal entities. This specification is neutral regarding the formal specification of temporal entities.</p>
    
    <h4>Instants and Intervals</h4>
    
    <p>Following the concepts of the Time Ontology (<a href="http://www.w3.org/TR/owl-time/">http://www.w3.org/TR/owl-time/</a>), a temporal entity can be a time instant or a time interval.</p>
    <section id="def-timestamped-graph">
    <h3>Timestamped graph</h3>
    
      <p>A <em>timestamped graph</em> is defined as an RDF Dataset under the RDF Dataset semantics that <a href="http://www.w3.org/TR/2014/NOTE-rdf11-datasets-20140225/#each-named-graph-defines-its-own-context">"each named graph defines its own context"</a> (see <a href="#semantics"></a>) and where a particular triple in the default graph has been designated as the timestamp triple, with the following constraints:</p>
    
    <ol>
      <li>There is exactly one named graph pair <code>&lt;n, G></code> in the RDF Dataset (where <code>G</code> is an <a href="http://www.w3.org/TR/rdf11-concepts/#section-rdf-graph">RDF graph</a>, and <code>n</code> is an IRI or blank node).</li>
      <li>The timestamp triple has the form <code>&lt;n, p, t></code>, where <code>n</code> is defined in the previous item, and <code>p</code> is a timestamp predicate that captures the relationship between the temporal entity <code>t</code>, called the timestamp, and the graph <code>G</code>.</li>
    </ol>
      <p class="note">There may be multiple triples in the default graph, including multiple triples using timestamp predicates, 
        but exactly one triple must be designated as the timestamp triple.</p>
      <p class="ednote">Due to the assertion of the timestamp triple, the context referred to in "each named graph defines its own context" has a temporal aspect to it.
        Other aspects of this context may be asserted by additional triples in the default graph of the timestamped graph.
        Such triples are not required to have timestamp predicates, and thus may be about non-temporal aspects of the context,
        e.g. the authority or the sensor device.
        That is, we require the context to have a temporal aspect to it, but the context is not limited to temporal aspects.
        Thus, it would be misleading to call it a "temporal context".
      </p>
      <p class="ednote">The part of the definition above that points to RDF Dataset semantics really belongs in the semantics section, not
      in this definition, which should be purely syntax.
      We need additional informative text that gives the motivation for these definitions.
      </p>
      
    <p class="ednote">This definition does not permit the timestamp to be omitted, which is one of the data structures
      that is considered to be in-scope by the requirements document.
    </p>
      <p>
      A sequence of RDF graphs (or named graphs, or RDF datasets) MAY be physically received by an RSP engine, 
      which MAY then create an RDF stream from it by adding timestamps, e.g. indicating the time of arrival. 
      The original sequence is not itself an RDF stream.
    </p>
      <p class="note">
        This definition allows the timestamp to be an IRI or blanknode. 
        Additional information about the timestamp may be provided in the default graph (e.g. through properties in the OWL Time Ontology), 
        but this is not required by the definition of timestamped graph.
    </p>
      
      <p>A <em>literal-timestamped graph</em> is a timestamped graph whose timestamp <code>t</code> is an rdf:Literal.</p>
      
      <p class="ednote">Merge and union of RDF streams with non-literal-timestamped graphs may not be defined. See <a href="#merge-union"></a>.</p>
          
      <p class="ednote">The timestamp predicate <code>p</code> may be drawn from a community agreed 
        vocabulary (<a href="https://github.com/streamreasoning/RSP-QL/issues/10">Issue 10</a>).
        The timestamp predicate may also be user-defined.
      </p>

      <p>
        The format in the examples of this document follows <a href="http://www.w3.org/TR/trig/">TriG</a>, although does not imply any specific serialization or formatting; 
        it simply shows the data structured according to the RDF stream model.  
        When the default graph of a timestamped graph contains only one triple, this must be the timestamp triple, so there is no need of an additional format to designate it. 
        In examples of timestamped graphs having more than one triple in the default graph, the first triple of the default graph to occur in the serialization
        is assumed to be the timestamp triple.
        Prefixes (e.g. <code>prov:</code>, <code>dul:</code>) are used, without explicitly defining their expansion, for readability.</p>
      <p class="ednote">A non-normative subsection should be created to hold all the information about the formatting of examples, and there
        the expansion of all prefixes that are used in examples can be defined.</p>
      
    <aside class="example" title="Literal-Timestamped Graph">
    
      <p>The following timestamped graph contains a named graph pair <code>&lt;:g1, G></code> where the graph <code>G</code> 
        contains two triples that state that entities <code>:darko</code> and <code>:axel</code> are in the <code>:RedRoom</code>. 
        The timestamp predicate <code>p</code> used in this example is the [[PROV-O]] property 
        <a href="https://www.w3.org/TR/prov-o/#generatedAtTime"><code>prov:generatedAtTime</code></a>.
        The purpose of this timestamp triple is to add a temporal aspect to the context of the named graph pair,
        to the effect that the temporal entity <code>"2001-10-26T21:32:52Z"^^xsd:dateTime</code> 
        is the time at which the entity <code>:g1</code> "was completely created and is available for use".
        The details of the semantics of the named graph pair in a timestamped graph are provided in <a href="#semantics"></a>
      </p>
    
      <pre><code  class="highlight">:g1 {:axel :isIn :RedRoom. :darko :isIn :RedRoom} {:g1,prov:generatedAtTime,"2001-10-26T21:32:52Z"^^xsd:dateTime}
</code></pre>
    </aside>
      
      <p class="ednote">According to the semantics defined in <a href="#semantics"></a>, the assertion of the named graph pair
        means that the graph denoted by <code>:g</code> entails the two triples <code>:axel :isIn :RedRoom</code>
      and <code>:darko :isIn :RedRoom</code>, under whatever entailment regime is being considered. 
        It does not assert those triples directly, nor does it assert that these triples
        are actually in that graph. Further, it does not rule out additional entailments of <code>:g</code>.
        These details are best explained in the semantics section itself, although it would probably be helpful
        to have some informative explanation near the beginning to avoid confusion.
    </p>
      
      <aside class="example" title="Non-Literal-Timestamped Graph">
        <p>The following timestamped graph contains a named graph pair <code>&lt;:g2, G></code> where the graph <code>G</code> 
          contains one triple that states that entity <code>:axel</code> leaves the <code>:BlueRoom</code>. 
          The timestamp predicate used in this example is the DOLCE+DnS Ultralite property 
          <a href="http://www.loa-cnr.it/ontologies/DUL.owl#isObservableAt"><code>dul:isObservableAt</code></a>.
          The purpose of this timestamp triple is to add a temporal aspect to the context of the named graph pair,
          to the effect that there is 
          some time <code>_:t2</code> at which an observation could have been (or be) made where the results of that observation
          are described by the entity <code>:g2</code>.
          There is an additional triple in the default graph that compares the observable time
          to some other time <code>_:t1</code> using the Allen interval relation 
          <a href="https://www.w3.org/2006/time#after"><code>owl:after</code></a>
          from [[OWL-TIME]].
        </p>
        <pre><code class="highlight">
          :g2 dul:isObservableAt _:t2.
          :g2 {:axel :leave :BlueRoom. }
          _:t2 time:after _:t1
        </code></pre>
      </aside>
    </section>
    
    <h3>RDF Stream</h3>
    
      <p>An <em>RDF stream</em> <code>S</code> consists of a sequence of timestamped graphs whose elements sharing the same predicate are ordered by the partial order associated with this predicate on the timestamps. I.e., if a stream <code>S</code> contains elements <code>S(i)</code> and <code>S(j)</code> with <code>i &lt; j</code> whose timestamp triples contain the same timestamp predicate <code>p</code>, then it should not be the case that the timestamp of <code>S(i)</code> is greater than the timestamp of <code>S(j)</code>. </p>
    
    <p><strong>Order:</strong> The partial order MUST respect the natural order of time. In particular, if every time instant within the closure of temporal entity <code>X</code> is earlier than every time instant within the closure of temporal entity <code>Y</code>, then <code>X &lt;= Y</code> (where closure of a time instant <code>t</code> is defined as the degenerate interval <code>[t, t]</code>, and closure of an interval is defined in the usual way) </p>
    
    <p>Furthermore, the usual mathematical requirements of a partial order apply:</p>
    
    <ul>
      <li>a) Reflexivity <code>X &lt;= X</code></li>
      <li>b) Antisymmetry <code>X &lt;= Y</code> and <code>Y &lt;= X</code> implies <code>X = Y</code></li>
      <li>c) Transitivity <code>X &lt;= Y</code> and <code>Y &lt;= Z</code> implies <code>X &lt;= Z</code>. </li>
    </ul>
      
      <p class="ednote">Time-boundedness properties on RDF streams behave better if it is required that the set of temporal entities for each timestamp predicate is pairwise bounded. I.e., for each pair of temporal entities in the set, there is a temporal entity in the set that is an upper bound of both, as well as a temporal entity in the set that is a lower bound of both.</p>
      
    <p class="ednote">The comparability between any pair of elements of an RDF stream must be completely determined
      from the default graphs of the elements.
    Otherwise the ordering could be revealed by a subsequent element, inducing retroactively an
    ordering requirement on previous stream elements.</p>
    
    <p>On the following we may refer to RDF stream simply as stream.</p>
    
    <aside class="example highlight" title="RDF Stream">
    
    <p>An RDF stream produces data that indicates where a person is at a given time. The timestamp predicate <code>p</code> used in this example is the PROV `<code>prov:generatedAtTime</code>. In this example the named graphs (<code>:g1</code>,<code>:g2</code>, etc.) contain the streaming data contents (for brevity the contents are represented by the dots <code>...</code>). </p>
    
    <pre  class="example highlight" title="RDF Stream Abbreviated"><code>:g1 {...}{:g1,prov:generatedAtTime,t1}
:g2 {...} {:g2, prov:generatedAtTime, t2}
:g3 {...} {:g3, prov:generatedAtTime, t3}
:g4 {...} {:g4, prov:generatedAtTime, t4}
...
</code></pre>
    
    <p>We can expand the content of each named graph, which is a set of triples:</p>
    
    <pre  class="example highlight" title="RDF Stream Expanded"><code>
:g1 {:axel :isIn :RedRoom. :darko :isIn :RedRoom} {:g1, prov:generatedAtTime, t1}
:g2 {:axel :isIn :BlueRoom. }                     {:g2, prov:generatedAtTime, t2}
:g3 {:minh :isIn :RedRoom. }                      {:g3, prov:generatedAtTime, t3}
...
</code></pre>
      </p>
    </aside>
    
    <p class="note">There can be multiple graphs with the same timestamp in the stream.</p>
    
      <p class="ednote">It has been pointed out that this statement might be problematic, as graphs cold no longer be used for punctuation purposes. Comparatively, we have not found a constraint on this in similar models e.g. CQL: <em>there could be zero, one, or multiple elements with the same timestamp in a stream</em>.</p>
    
    <h3>Substream</h3>
    
    <p>A <em>substream</em> (also known as window) <code>S'</code> of a stream <code>S</code> is a subsequence of <code>S</code>.</p>
    
    <h4>Time-bounded Substream</h4>
    
    <p>A <em>time-bounded substream</em> is defined by two time instances providing a lower bound <code>t_l</code> and an upper bound <code>t_u</code> where <code>t_l &lt;= t_u</code>. A timestamped graph <code>(g_i,p_i,t_i)</code> is in the time-bounded substream if and only if <code>t_l &lt;= t_i &lt;= t_u</code>.</p>
    
    <h4>Count-bounded Substream</h4>
    
    <p>A <em>count-bounded substream</em> is defined by a time instance <code>t</code> and an integer value <code>n</code> that represents the number of timestamped graphs to include in the count-bounded substream. The count-bounded substream consists of the <code>n</code> timestamped graphs at or before time instance <code>t</code>. That is, a timestamped graph <code>(g_i,p_i,t_i)</code> is in the count-bounded substream if and only if there are less than or equal to <code>n</code> timestamped graphs between it and the time instance <code>t</code>.</p>
    
    <p  class="note">A bounded substream maintains the timestamped graph contexts of the original stream.</p>
    
    <blockquote>
      <p>See <a href="https://github.com/streamreasoning/RSP-QL/issues/11">Issue 11</a>.</p>
    </blockquote>
    </section>
    <section>
    
    <h2>Stream Merger and Union Operations</h2>
    </section>
    <section id="window-functions"> 
    
    <h2>Window Functions</h2>
      <p>Given any two timestamped graphs, <code>TSG1</code> and <code>TSG2</code>, we say that <code>TSG2</code> <em>covers</em> <code>TSG1</code> 
      (denoted <code>TSG1 &le; TSG2</code>) if and only if <code>TSG1</code> and <code>TSG2</code> have the same timestamp predicate <code>P</code>
        and the timestamps, <code>t1</code> and <code>t2</code> resp., satisfy <code>t1 &le;<sub>P</sub> t2</code>, where 
        <code>&le;<sub>P</sub></code> is the temporal partial order 
        associated with the timestamp predicate <code>P</code>.
    </p>
      
      <p class="ednote">The definition of cover, and the following discussion of it, could probably be moved to follow shortly after the definition of timestamped graph so that
      this concept could be used in other definition.</p>
      
      <p class="note">The relation <code>&le;</code> between timestamped graphs is a preorder (a reflexive, transitive binary relation).
        It is not a partial order because it doesn't have the antisymmetry property (<code>a &le; b</code> and <code>b &le; a</code> implies <code>a = b</code>.) 
      </p>
      
      <aside class="example highlight" title="Distinct Timestamped Graphs That Cover Each Other">
        <p>Two timestamped graphs that have the same timestamp predicate and the same timestamp but different named graphs
          cover each other, but are not equal.
          This demonstrates that the "cover" relation is not antisymmetric.
        </p>
      </aside>
      
      <p>A <em>window</em> <code>S'</code> of an RDF stream <code>S</code> is a substream of <code>S</code> such that 
        if <code>S'(i)</code> and <code>S'(j)</code> are two elements of <code>S'</code>
          and <code>S'(i) &le; S'(j)</code>, and further if <code>S'(i) &le; S(k) &le; S'(j)</code> for some element <code>S(k)</code> of <code>S</code>, 
            then <code>S(k)</code> is an element of <code>S'</code>.      
      </p>
      <p class="note">Informally, a window is a temporally-contiguous selection from the original stream, without gaps.</p>
      
      <p class="ednote">The definition of window should be moved to the substream section.</p>
      
      <p>A <em>window function</em> is a partial function from RDF streams to their windows that preserves isomorphism.
        That is, if <code>w</code> is a window function, with isomorphic streams <code>S1</code> and <code>S2</code> in its domain,
        then <code>w(S1)</code> is isomorphic to <code>w(S2)</code>.
      </p>
    
      <p  class="ednote">The term "window operator" is reserved for later use to return a sequence of windows.</p>
      
      <p>The set of temporal entities associated with a timestamp predicate is called the <em>timescale of the timestamp predicate.</em></p>
      
      <p class="ednote">The term "timescale" should be introduced when timestamp predicate is defined.
      And a better term might be "time-plenum", because "timescale" suggests measurement, but we do not
      (yet) require a temporal metric to be defined.</p>
                    
    <p>The most common types of window functions in practice are time-based and count-based.</p>
    
    <section id="time-based-window-functions">
    <h3>Time-based window functions</h3>
      <p>Because the timescale for each timestamp predicate is partially ordered, we may define a <em>temporal interval
        of a timestamp predicate</em>
      to be an interval, in the usual sense for partial orders, within its timescale.
      </p>
      <p class="note">Recall that intervals need not be bounded and need not be closed, and are
      specified in terms of two, one or zero inequality conditions based on the partial order or its induced strict order.</p>
      
      <p>A <em>time-based window function</em> <code>w</code> is a window function specified by 
        a finite set <code>w<sub>P</sub></code> of timestamp predicates  together with temporal
        intervals <code>w<sub>J</sub>(P)</code> of each timestamp predicate <code>P</code> in <code>w<sub>P</sub></code>, such that 
        for every stream <code>S</code>, 
        an element <code>S(i)</code> of <code>S</code> is a member of <code>w(S)</code> if and only if
        the timestamp predicate  <code>P</code> of <code>S(i)</code> is in <code>P</code> and
        the timestamp <code>t</code> of <code>S(i)</code> is contained in <code>w<sub>J</sub>(P)</code>.
      </p>
    
      <p class="note">The substream resulting from the application of a time-based window function is time-bounded.</p>
    </section>
      <section id="temporal-count-based-window-functions">
      <h3>Temporal-count-based window functions</h3>
      <p>A <em>temporal-count-based window function</em> <code>w</code> is a window function specified by
        a finite set <code>w<sub>P</sub></code> of timestamp predicates together with
        semi-infinite temporal intervals <code>w<sub>J</sub>(P)</code> of each timestamp predicate <code>P</code> in <code>w<sub>P</sub></code>
        with endpoints <code>w<sub>T</sub>(P)</code>,
        and positive integers <code>w<sub>N</sub>(P)</code>, for each timestamp predicate <code>P</code> in <code>w<sub>P</sub></code> such that
        for every stream <code>S</code>, 
        an element <code>S(i)</code> of <code>S</code> is a member of <code>w(S)</code> if and only if
        the timestamp predicate  <code>P</code> of <code>S(i)</code> is in <code>P</code> and
        <ul>          
          <li><code>t</code> is the timestamp of <code>S(i)</code>,</li>
          <li><code>T</code> is the set of temporal entities that are timestamps for elements of <code>S</code>
            with timestamp <code>P</code> that belong to <code>w<sub>J</sub>(P)</code>
            and belong to the closed interval between <code>t</code> and <code>w<sub>T</sub>(P)</code>, and</li>
          <li>the cardinality of <code>T</code> is less than or equal to  <code>w<sub>N</sub>(P)</code></li>
          </li>
        </ul>
      </p>
      
      <aside class="note">The above definition of temporal-count-based window function allows the following characteristics
        to be set indepndently for each timestamp predicate of concern:
        <ul>
          <li>future-facing or past-facing orientation,</li>
          <li>inclusive or exclusive temporal anchor,</li>
          <li>depth.</li>
        </ul>
      </aside>
      
      <p class="note">The substream resulting from the application of a temporal-count-based window function is temporal-count-bounded.</p>
      
      <p class="note">Due to the potential for stream elements with incomparable or duplicate timestamps, the number of elements in the substream having a particular
        timestamp predicate
      is not guaranteed to be equal to the depth specified for the predicate by the temporal-count-based window. </p>
      
      <p class="ednote">
       Applications that require a substream with an exact number of elements for a specified timestamp predicate
       might randomly discard elements after applying a temporal-count-based window function, according to some criterion, e.g.  
       extreme elements (maximal or minimal, depending on the orientation of the counting).
      However, this extra step causes the process to be nondeterministic, and hence is not a function 
      (a problem that might be resolved by defining a window relation instead of a function.)
      If elements are discarded in a nonrandom fashion based on their order in the stream sequence, then this
      would be a function, but would not preserve isomorphism, and so would not be a window function. 
      </p>
      
      <p class="note">Temporal-count-based window functions with future-facing orientation on timestamp 
        predicates whose timescale is not totally-ordered are not computable, because 
      in general it is not possible to know, at any point in the reception of the stream, whether there are further elements of the stream that would be selected
      by the temporal-count-based window function.</p>
      </section>
      
      <section id="window-relations">
        <h3>Window relations</h3>
        
        <p>A <em>window relation</em> is a binary relation on RDF streams (a relation having an extension which is a set of pairs of RDF streams) 
          such that the second element in the pair is
          a window of the first element and preserves isomorphism.
          That is, if <code>&lt;S1, S2&gt;</code> is a member of the extension of a window relation <code>W</code>, 
          and <code>S3</code> and <code>S4</code> are isomorphic to <code>S1</code> and <code>S2</code>, resp., then 
          <code>&lt;S3, S4&gt;</code> is also a member of the extension of <code>W</code>.
        </p>

        <p>A <em>length-based window relation</em> <code>W</code> is a window relation specified by
          a finite set <code>W<sub>P</sub></code> of timestamp predicates together with the following parameters for each timestamp predicate <code>p</code> in <code>W<sub>P</sub></code>:
          <ul>
            <li>a semi-infinite temporal interval <code>W<sub>J</sub>(P)</code> of timestamp predicate <code>P</code> (the interval of <code>P</code>);</li>
            <li>a temporal entity <code>W<sub>T</sub>(P)</code> which is the finite endpoint of <code>W<sub>J</sub>(P)</code> (the temporal reference of <code>P</code>);</li>
            <li>a positive integer <code>W<sub>N</sub>(P)</code> (the length of <code>P</code>)</li>
          </ul>
          The extension of a length-based window relation is defined as follows:
          Let <code>S</code> be an RDF stream with window <code>S'</code>.
          Define <code>T(P)</code> to be the set of temporal entities that are timestamps for elements of <code>S</code>
          that belong to <code>W<sub>J</sub>(P)</code>, and 
          <code>T'(P)</code> to be the set of temporal entities that are timestamps for elements of <code>S'</code>.
          The pair <code>&lt;S, S'&gt;</code> is a member of <code>W</code> 
          if and only if
          the cardinality of <code>T'(P)</code> is equal to the minimum of <code>W<sub>N</sub>(P)</code>
          and the cardinality of the set <code>T(P)</code> and
          for each element <code>S'(i)</code> of <code>S'</code>
          <ul>          
            <li>the timestamp predicate  <code>P</code> of <code>S'(i)</code> is in <code>W<sub>P</sub></code>, and</li>          
            <li> the timestamp <code>t</code> of <code>S'(i)</code> is in <code>W<sub>J</sub>(P)</code>.</li>
          </ul>
        </p>
        
      </section>
    </section>
      
    <!--<h2>References:</h2>
    
    <ul>
      <li>EP-SPARQL: a unified language for event processing and stream reasoning.
        Anicic, D., Fodor, P., Rudolph, S., &amp; Stojanovic, N. In WWW (p. 635-644). ACM. 2011.</li>
      <li>C-SPARQL: a Continuous Query Language for RDF Data Streams. 
        Barbieri, D. F., Braga, D., Ceri, S., Della Valle, E., &amp; Grossniklaus, M. Int. J. Semantic Computing, 4(1), 3-25. 2010.</li>
      <li>Enabling query technologies for the semantic sensor web. 
        Calbimonte, J.-P., Jeung, H., Corcho, Ó., &amp; Aberer, K. Int. J. Semantic Web Inf. Syst., 8(1), 43-63. 2012.</li>
      <li>RSP-QL Semantics: a Unifying Query Model to Explain Heterogeneity of RDF Stream Processing Systems. 
        D. Dell’Aglio, E. Della Valle, J.-P. Calbimonte, O. Corcho. Int. J. Semantic Web Inf. Syst, 10(4). (in press). 2015.</li>
      <li>A Native and Adaptive Approach for Unified Processing of Linked Streams and Linked Data.
        Phuoc, D. L., Dao-Tran, M., Parreira, J. X., &amp; Hauswirth, M.In ISWC (Vol. 7031, p. 370-388). Springer. 2011.</li>
      <li>LARS: A Logic-based Framework for Analyzing Reasoning over Streams.
        Beck, H., Dao-Tran, M., Eiter, T., Fink, M. In AAAI. 2015.</li>
      <li>RDF 1.1: On Semantics of RDF Datasets. Zimmerman, Antoine, ed.. 2014.  <a href="http://www.w3.org/TR/2014/NOTE-rdf11-datasets-20140225">http://www.w3.org/TR/2014/NOTE-rdf11-datasets-20140225</a>.</li>
    </ul>-->
    
    <blockquote>
      <p class="note">this example could be integrated to the main text body</p>
      
      <h3>Beyond time instants: intervals &amp; more</h3>
      
      <p>Usign the previously described model, intervals can be specified for a graph in the following way: Given p1 and p2 representing start and end time predicates, then <code>(g,p1,t1)</code> and <code>(g,p2,t2)</code> denote that g is defined in an interval [t1,t2]. As an example:</p>
      
      <pre  class="example highlight" title="RDF Stream with Two Timestamp Predicates for One Named Graph"><code>:g_1, :startsAt, "2015-06-18T12:00:00"^^xsd:dateTime
:g_1, :endsAt, "2015-06-18T13:00:00"^^xsd:dateTime
</code></pre>
      
      <p>Or even:</p>
      
      <pre  class="example highlight" title="RDF Stream with Interval Timestamp"><code>:g_2 :validBetween
    [:startsAt "2015-06-18T12:00:00"^^xsd:dateTime;
    :endsAt "2015-06-18T13:00:00"^^xsd:dateTime]
</code></pre>
    </blockquote>
    
    <!-- CONFORMANCE -->
    
    <section id="conformance">
    </section>
    
  </body>
</html>

<!DOCTYPE html>
<html>
  <head>
    <title>RDF Stream Abstract Syntax and Semantics</title>
    <meta charset="utf-8">
      <script src="http://www.w3.org/Tools/respec/respec-w3c-common"
            async class="remove"></script>
      <script class="remove">
      var respecConfig = {
          specStatus: "CG-DRAFT",
          edDraftURI: "http://streamreasoning.github.io/RSP-QL/Abstract%20Syntax%20and%20Semantics%20Document/",
          shortName:  "rdf-stream-semantics",
          editors: [
            {
              name:       "Editor 1",
              company:    "Company 1",
              companyURL: "http://example1.com/",
              mailto: "ed1@example1.com"
            },
            {
              name:       "Editor 2",
              company:    "Company 2",
              companyURL: "http://example2.com/",
              mailto: "ed2@example1.com"
            }
          ],
          authors: [
            {
              name:       "Tara Athan",
              company:    "Athan Services",
              companyURL: "http://athant.com",
              mailto: "taraathan@gmail.com"
            },
            {
              name:       "Author 2",
              company:    "Company 2",
              companyURL: "http://example2.com/",
              mailto: "auth2@example1.com"
            }
          ],
          wg:           "RDF Stream Processing Community Group",
          wgURI:        "https://www.w3.org/community/rsp/",
          wgPublicList: "public-rsp",

          localBiblio:  {
            "LINEARCOMPOSITION": {
              title: "Multi-device Linear Composition on the Web: Enabling Multi-device Linear Media with HTMLTimingObject and Shared Motion",
              href: "https://sites.google.com/site/mediasynchronization/Paper4_Arntzen_webComposition_CR.pdf?attredirects=0&d=1",
              authors: [
                "Ingar M. Arntzen",
                "Njål T. Borch",
                "François Daoust",
                "Dominique Hazaël-Massieux"
              ]
            },
            "MSV": {
              title:    "The Media State Vector: A unifying concept for multi-device media navigation",
              href:     "http://dl.acm.org/citation.cfm?doid=2457413.2457427",
              authors:  [
                "Ingar M. Arntzen",
                "Njål T. Borch",
                "Christopher P. Needham"
              ]
            },
            "DVB-CSS": {
              title: "ETSI TS 103 256-2 V1.1.1 Digital Video Broadcasting (DVB); Companion Screens and Streams; Part 2: Content Identification and Media Synchronization",
              href: "http://www.etsi.org/modules/mod_StandardSearch/pdf.png"
            },
            "SHAREDMOTION": {
              title: "Shared Motion",
              href: "http://motioncorporation.com"
            },
            "MEDIASYNC":{
              title: "MediaSync",
              href: "https://github.com/webtiming/mediasync"
            },
            "SEQUENCER" : {
              title: "Open-source sequencer library",
              href: "https://github.com/webtiming/sequencer"
            }
          },
          otherLinks: [
            {
              key: "Version history",
              data: [
                {
                  value: "GitHub streamreasoning/RSP-QL/commits",
                  href: "https://github.com/streamreasoning/RSP-QL/commits/"
                }
              ]
            },
            {
              key: "Participate",
              data: [
                {
                  value: "GitHub streamreasoning/RSP-QL",
                  href: "https://github.com/streamreasoning/RSP-QL"
                },
                {
                  value: "File an issue",
                  href: "https://github.com/streamreasoning/RSP-QL/issues/new"
                },
                {
                  value: "Open issues",
                  href: "https://github.com/streamreasoning/RSP-QL/issues/"
                },
                {
                  value: "Mailing-list (public-rsp@w3.org)",
                  href: "https://lists.w3.org/Archives/Public/public-rsp/"
                }
              ]
            }
          ],

          issueBase: "https://github.com/streamreasoning/RSP-QL/issues/",
          githubAPI: "https://api.github.com/repos/streamreasoning/RSP-QL"
      };
    </script>
      <style type="text/css">
      table { border-collapse: collapse; border-style: hidden hidden none hidden; }
      table thead, table tbody { border-bottom: solid; }
      table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
    </style>
  </head>
  <body>
    <!-- ABSTRACT -->
    
    <section id="abstract">
    </section>
    
    <!-- STATUS OF DOCUMENT -->
    
    <section id="sotd">
      <p>
        The specification is intended for discussion within the RDF Stream Processing Community Group. Its content does not yet represent the consensus of the Community Group.
      </p>
      <p class="warning">
        This specification is incomplete.
      </p>
    </section>
    
    <!-- INTRODUCTION -->
    
    <section class="informative">
      <h2>Introduction</h2>
    </section>
    
    <section>
      
    <h2>RSP Data model</h2>
      
    <h3>Temporal entities</h3>
    
    <p>Let T denote the set of temporal entities. This specification is neutral regarding the formal specification of temporal entities.</p>
    
    <h4>Instants and Intervals</h4>
    
    <p>Following the concepts of the Time Ontology (<a href="http://www.w3.org/TR/owl-time/">http://www.w3.org/TR/owl-time/</a>), a temporal entity can be a time instant or a time interval.</p>
    
    <h3>Timestamped graph</h3>
    
    <p>A <em>timestamped graph</em> is defined as an RDF Dataset under the RDF Dataset semantics that <a href="http://www.w3.org/TR/2014/NOTE-rdf11-datasets-20140225/#each-named-graph-defines-its-own-context">each graph defines its own context</a> with the following constraints.</p>
    
    <ol>
      <li>There is a single named graph pair (n, g) in the RDF Dataset (where <code>g</code> is an <a href="http://www.w3.org/TR/rdf11-concepts/#section-rdf-graph">RDF graph</a>, and <code>n</code> is an IRI or blank node).</li>
      <li>There is a <del>single</del> triple in the default graph of the RDF Dataset, and it has the form (n, p, t), where <code>n</code> is defined in the previous item, <code>p</code> is a predicate that captures the relationship between the temporal entity <code>t</code>, called the timestamp, and the graph <code>g</code>.</li>
    </ol>
    
    <p>Limitations of the definition:</p>
    
    <ul>
      <li>does <strong>not</strong> allow the default graph of a timestamped graph to have more than triple.</li>
    </ul>
    
    <blockquote>
      <p><strong>Discussion:</strong> There could be multiple timestamps associated with a graph <code>g</code>, e.g. a start time and an end time, or a generated time and a system processing time. The predicate <code>p</code> should be drawn from a community agreed vocabulary (<a href="https://github.com/streamreasoning/RSP-QL/issues/10">Issue 10</a>).</p>
      
      <p><strong>Discussion:</strong> More than one triple may be necessary to represent the time metadata for each graph.</p>
    </blockquote>
    
    <h4>Example:</h4>
    
    <p>The following timestamped graph <code>:g1</code> contains 2 triples that state that Darko and Axel are in the Red Room. The <code>p</code> predicate used in this example is the PROV `<code>prov:generatedAtTime</code>. In this example the named graph <code>:g1</code> contains the data contents (triples). The format in the example follows <a href="http://www.w3.org/TR/trig/">TriG</a>, although does not imply any specific serialization or formatting, it simply shows the data structured according to the RDF stream model. Prefixes (e.g. <code>prov:</code>) are used for readability.</p>
    
      <pre class="example highlight" title="Timestamped Graph with IRI Graph Name and Quads"><code>:g1 {:axel :isIn :RedRoom. :darko :isIn :RedRoom} {:g1,prov:generatedAtTime,"2001-10-26T21:32:52Z"}
</code></pre>
    
    <h3>RDF Stream</h3>
    
    <p>A <em>RDF stream</em> <code>S</code> consists of a sequence of timestamped graphs whose elements sharing the same predicate are ordered by the partial order associated with this predicate on the timestamps. </p>
    
    <p><strong>Order:</strong> The partial order must respect the natural order of time. In particular, if every time instant within the closure of temporal entity <code>X</code> is earlier than every time instant within the closure of temporal entity <code>Y</code>, then <code>X &lt;= Y</code> (where closure of a time instant <code>t</code> is defined as the degenerate interval <code>[t, t]</code>, and closure of an interval is defined in the usual way) </p>
    
    <p>Furthermore, the usual mathematical requirements of a partial order apply:</p>
    
    <ul>
      <li>a) Reflexivity <code>X &lt;= X</code></li>
      <li>b) Antisymmetry <code>X &lt;= Y</code> and <code>Y &lt;= X</code> implies <code>X = Y</code></li>
      <li>c) Transitivity <code>X &lt;= Y</code> and <code>Y &lt;= Z</code> implies <code>X &lt;= Z</code>. </li>
    </ul>
    
    <p>On the following we may refer to RDF stream simply as stream.</p>
    
    <h4>Example:</h4>
    
    <p>A stream produces data that indicates where a person is at a given time. The <code>p</code> predicate used in this example is the PROV `<code>prov:generatedAtTime</code>. In this example the named graphs (<code>:g1</code>,<code>:g2</code>, etc.) contain the streaming data contents (for brevity the contents are represented by the dots <code>...</code>). </p>
    
    <pre  class="example highlight" title="RDF Stream Abbreviated"><code>:g1 {...}{:g1,prov:generatedAtTime,t1}
:g2 {...}{:g2,prov:generatedAtTime,t2}
:g3 {...}{:g3,prov:generatedAtTime,t3}
:g4 {...}{:g4,prov:generatedAtTime,t4}
...
</code></pre>
    
    <p>We can expand the content of each named graph, which is a set of triples:</p>
    
    <pre  class="example highlight" title="RDF Stream Expanded"><code>:g1 {:axel :isIn :RedRoom. :darko :isIn :RedRoom} {:g1,prov:generatedAtTime,t1}
:g2 {:axel :isIn :BlueRoom. }                     {:g2,prov:generatedAtTime,t2}
:g3 {:minh :isIn :RedRoom. }                      {:g3,prov:generatedAtTime,t3}
...
</code></pre>
    
    <blockquote>
      <p><strong>Discussion</strong>: Given a certain <code>p</code>, elements on the stream having that predicate are ordered according to <code>t</code>. If the stream contains elements s1 and s2 associated with the same predicate, with s1 preceding s2, then it should not be the case that the timestamp of s1 is greater than the timestamp of s2.</p>
    </blockquote>
    
    <p><strong>Observation:</strong> There can be multiple graphs with the same timestamp in the stream.</p>
    
    <blockquote>
      <p>It has been pointed out that this statement might be problematic, as graphs cold no longer be used for punctuation purposes. Comparatively, we have not found a constraint on this in similar models e.g. CQL: <em>there could be zero, one, or multiple elements with the same timestamp in a stream</em>. To verify.</p>
    </blockquote>
    
    <h3>Substream</h3>
    
    <p>A <em>substream</em> (also known as window) <code>S'</code> of a stream <code>S</code> is a subsequence of <code>S</code>.</p>
    
    <h4>Time-bounded Substream</h4>
    
    <p>A <em>time-bounded substream</em> is defined by two time instances providing a lower bound <code>t_l</code> and an upper bound <code>t_u</code> where <code>t_l &lt;= t_u</code>. A timestamped graph <code>(g_i,p_i,t_i)</code> is in the time-bounded substream if and only if <code>t_l &lt;= t_i &lt;= t_u</code>.</p>
    
    <h4>Count-bounded Substream</h4>
    
    <p>A <em>count-bounded substream</em> is defined by a time instance <code>t</code> and an integer value <code>n</code> that represents the number of timestamped graphs to include in the count-bounded substream. The count-bounded substream consists of the <code>n</code> timestamped graphs at or before time instance <code>t</code>. That is, a timestamped graph <code>(g_i,p_i,t_i)</code> is in the count-bounded substream if and only if there are less than or equal to <code>n</code> timestamped graphs between it and the time instance <code>t</code>.</p>
    
    <p  class="note">A bounded substream maintains the timestamped graph contexts of the original stream.</p>
    
    <blockquote>
      <p>See <a href="https://github.com/streamreasoning/RSP-QL/issues/11">Issue 11</a>.</p>
    </blockquote>
    </section>
    <section>
    
    <h2>Stream Merger and Union Operations</h2>
    </section>
    <section id="window-functions"> 
    
    <h2>Window Functions</h2>
      <p>Given any two timestamped graphs, <code>TSG1</code> and <code>TSG2</code>, we say that <code>TSG2</code> <em>covers</em> <code>TSG1</code> 
      (denoted <code>TSG1 &le; TSG2</code>) if and only if <code>TSG1</code> and <code>TSG2</code> have the same timestamp predicate <code>p</code>
        and the timestamps, <code>t1</code> and <code>t2</code> resp., satisfy <code>t1 &le; t2</code>.
    </p>
      
      <p class="ednote">The definition of cover, and the following discussion of it, could probably be moved to follow shortly after the definition of timestamped graph so that
      this concept could be used in other definition.</p>
      
      <p class="note">The relation <code>&le;</code> between timestamped graphs is a preorder (a reflexive, transitive binary relation).
        It is not a partial order because it doesn't have the symmetry property (<code>a &le; b</code> and <code>b &le; a</code> implies <code>a = b</code>.) 
      </p>
      
      <aside class="example highlight" title="Distinct Timestamped Graphs That Cover Each Other">
        <p>Two timestamped graphs that have the same timestamp predicate and the same timestamp but different named graphs
          cover each other, but are not equal.
          This demonstrates that the "cover" relation is not antisymmetric.
        </p>
      </aside>
      
      <p>A <em>window</em> <code>S'</code> of an RDF stream <code>S</code> is a substream of <code>S</code> such that 
        if <code>S'(i)</code> and <code>S'(j)</code> are two elements of <code>S'</code>
          and <code>S'(i) &le; S'(j)</code>, and further if <code>S'(i) &le; S(k) &le; S'(j)</code> for some element <code>S(k)</code> of <code>S</code>, 
            then <code>S(k)</code> is an element of <code>S'</code>.      
      </p>
      <p class="note">Informally, a window is a temporally-contiguous selection from the original stream, without gaps.</p>
      
      <p class="ednote">The definition of window should be moved to the substream section.</p>
      
      <p>A <em>window function</em> is a partial function from RDF streams to their windows that preserves isomorphism.
        That is, if <code>w</code> is a window function, with isomorphic streams <code>S1</code> and <code>S2</code> in its domain,
        then <code>w(S1)</code> is isomorphic to <code>w(S2)</code>.
      </p>
    
      <p  class="ednote">The term "window operator" is reserved for later use to return a sequence of windows.</p>
      
      <p>The set of temporal entities associated with a timestamp predicate is called the <em>timescale of the timestamp predicate.</em></p>
      
      <p class="ednote">The term "timescale" should be introduced when timestamp predicate is defined.
      And a better term might be "time-plenum", because "timescale" suggests measurement, but we do not
      (yet) require a temporal metric to be defined.</p>
                    
    <p>The most common types of window functions in practice are time-based and count-based.</p>
    
    <section id="time-based-window-functions">
    <h3>Time-based window functions</h3>
      <p>Because the timescale for each timestamp predicate is partially ordered, we may define a <em>temporal interval
        of a timestamp predicate</em>
      to be an interval, in the usual sense for partial orders, within its timescale.
      </p>
      <p class="note">Recall that intervals need not be bounded and need not be closed, and are
      specified in terms of two, one or zero inequality conditions based on the partial order or its induced strict order.</p>
      
      <p>A <em>time-based window function</em> <code>w</code> is a window function specified by 
        a finite set <code>w<sub>P</sub></code> of timestamp predicates  together with temporal
        intervals <code>w<sub>J</sub>(p)</code> of each timestamp predicate <code>p</code> in <code>w<sub>P</sub></code>, such that 
        for every stream <code>S</code>, 
        an element <code>S(i)</code> of S is a member of <code>w(S)</code> if and only if
        the timestamp predicate  <code>p</code> of <code>S(i)</code> is in <code>P</code> and
        the timestamp <code>t</code> of <code>S(i)</code> is contained in <code>w<sub>J</sub>(p)</code>.
      </p>
    
      <p class="note">The substream resulting from the application of a time-based window function is time-bounded.</p>
    </section>
      <section id="temporal-count-based-window-functions">
      <h3>Temporal-count-based window functions</h3>
      <p>A <em>temporal-count-based window function</em> <code>w</code> is a window function specified by
        a finite set <code>w<sub>P</sub></code> of timestamp predicates together with
        semi-infinite temporal intervals <code>w<sub>J</sub>(p)</code> of each timestamp predicate <code>p</code> in <code>w<sub>P</sub></code>
        with endpoints <code>w<sub>T</sub>(p)</code>,
        and positive integers <code>w<sub>N</sub>(p)</code>, for each timestamp predicate <code>p</code> in <code>w<sub>P</sub></code> such that
        for every stream <code>S</code>, 
        an element <code>S(i)</code> of S is a member of <code>w(S)</code> if and only if
        the timestamp predicate  <code>p</code> of <code>S(i)</code> is in <code>P</code> and
        <ul>          
          <li><code>t</code> is the timestamp of <code>S(i)</code>,</li>
          <li><code>T</code> is the set of temporal entities that are timestamps for elements of <code>S</code>
            with timestamp <code>p</code> that belong to <code>w<sub>J</sub>(p)</code>
            and belong to the closed interval between <code>t</code> and <code>w<sub>T</sub>(p)</code>, and</li>
          <li>the cardinality of <code>T</code> is less than or equal to  <code>w<sub>N</sub>(p)</code></li>
          </li>
        </ul>
      </p>
      
      <aside class="note">The above definition of temporal-count-based window function allows the following characteristics
        to be set indepndently for each timestamp predicate of concern:
        <ul>
          <li>future-facing or past-facing orientation,</li>
          <li>inclusive or exclusive temporal anchor,</li>
          <li>depth.</li>
        </ul>
      </aside>
      
      <p class="note">The substream resulting from the application of a temporal-count-based window function is temporal-count-bounded.</p>
      
      <p class="note">Due to the potential for stream elements with incomparable or duplicate timestamps, the number of elements in the substream having a particular
        timestamp predicate
      is not guaranteed to be equal to the depth specified for the predicate by the temporal-count-based window. </p>
      
      <p class="ednote">
       Applications that require a substream with an exact number of elements for a specified timestamp predicate
       might randomly discard elements after applying a temporal-count-based window function, according to some criterion, e.g.  
       extreme elements (maximal or minimal, depending on the orientation of the counting).
      However, this extra step causes the process to be nondeterministic, and hence is not a function 
      (a problem that might be resolved by defining a window relation instead of a function.)
      If elements are discarded in a nonrandom fashion based on their order in the stream sequence, then this
      would be a function, but would not preserve isomorphism, and so would not be a window function. 
      </p>
      
      <p class="note">Temporal-count-based window functions with future-facing orientation on timestamp 
        predicates whose timescale is not totally-ordered are not computable, because 
      in general it is not possible to know, at any point in the reception of the stream, whether there are further elements of the stream that would be selected
      by the temporal-count-based window function.</p>
      </section>
      
      <section id="window-relations">
        <h3>Window relations</h3>
        
        <p>A <em>window relation</em> is a binary relation on RDF streams (a set of pairs of RDF streams) such that the second element in the pair is
          a window of the first element and preserves isomorphism.
          That is, if <code>&lt;S1, S2%gt;</code> is a member of the extension of a window relation <code>w</code>, 
          and <code>S3</code> and <code>S4</code> are isomorhpic to <code>S1</code> and <code>S2</code>, resp., then 
          <code>&lt;S3, S4%gt;</code> is in the extension of <code>w</code>.
        </p>
        
      </section>
    </section>
      
    <!--<h2>References:</h2>
    
    <ul>
      <li>EP-SPARQL: a unified language for event processing and stream reasoning.
        Anicic, D., Fodor, P., Rudolph, S., &amp; Stojanovic, N. In WWW (p. 635-644). ACM. 2011.</li>
      <li>C-SPARQL: a Continuous Query Language for RDF Data Streams. 
        Barbieri, D. F., Braga, D., Ceri, S., Della Valle, E., &amp; Grossniklaus, M. Int. J. Semantic Computing, 4(1), 3-25. 2010.</li>
      <li>Enabling query technologies for the semantic sensor web. 
        Calbimonte, J.-P., Jeung, H., Corcho, Ó., &amp; Aberer, K. Int. J. Semantic Web Inf. Syst., 8(1), 43-63. 2012.</li>
      <li>RSP-QL Semantics: a Unifying Query Model to Explain Heterogeneity of RDF Stream Processing Systems. 
        D. Dell’Aglio, E. Della Valle, J.-P. Calbimonte, O. Corcho. Int. J. Semantic Web Inf. Syst, 10(4). (in press). 2015.</li>
      <li>A Native and Adaptive Approach for Unified Processing of Linked Streams and Linked Data.
        Phuoc, D. L., Dao-Tran, M., Parreira, J. X., &amp; Hauswirth, M.In ISWC (Vol. 7031, p. 370-388). Springer. 2011.</li>
      <li>LARS: A Logic-based Framework for Analyzing Reasoning over Streams.
        Beck, H., Dao-Tran, M., Eiter, T., Fink, M. In AAAI. 2015.</li>
      <li>RDF 1.1: On Semantics of RDF Datasets. Zimmerman, Antoine, ed.. 2014.  <a href="http://www.w3.org/TR/2014/NOTE-rdf11-datasets-20140225">http://www.w3.org/TR/2014/NOTE-rdf11-datasets-20140225</a>.</li>
    </ul>-->
    
    <blockquote>
      <p class="note">this example could be integrated to the main text body</p>
      
      <h3>Beyond time instants: intervals &amp; more</h3>
      
      <p>Usign the previously described model, intervals can be specified for a graph in the following way: Given p1 and p2 representing start and end time predicates, then <code>(g,p1,t1)</code> and <code>(g,p2,t2)</code> denote that g is defined in an interval [t1,t2]. As an example:</p>
      
      <pre  class="example highlight" title="RDF Stream with Two Timestamp Predicates for One Named Graph"><code>:g_1, :startsAt, "2015-06-18T12:00:00"^^xsd:dateTime
:g_1, :endsAt, "2015-06-18T13:00:00"^^xsd:dateTime
</code></pre>
      
      <p>Or even:</p>
      
      <pre  class="example highlight" title="RDF Stream with Interval Timestamp"><code>:g_2 :validBetween
    [:startsAt "2015-06-18T12:00:00"^^xsd:dateTime;
    :endsAt "2015-06-18T13:00:00"^^xsd:dateTime]
</code></pre>
    </blockquote>
    
    <!-- CONFORMANCE -->
    
    <section id="conformance">
    </section>
    
  </body>
</html>
